// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

//go:build integration

package integration

import (
	"net/http"
	"path"
	"testing"
	"time"

	json "github.com/goccy/go-json"
	"github.com/mariomac/guara/pkg/test"
	"github.com/stretchr/testify/require"

	"go.opentelemetry.io/obi/internal/test/integration/components/docker"
	"go.opentelemetry.io/obi/internal/test/integration/components/jaeger"
	ti "go.opentelemetry.io/obi/pkg/test/integration"
)

const (
	staticTraceID   = "12345678901234567890123456789012" // Easy to spot
	forwardedSpanID = "1111111111111111"                 // Span ID used in forwarded traceparent
)

// TestTraceparentExtraction validates that the eBPF tpinjector correctly:
// 1. Extracts existing Traceparent headers from HTTP requests
// 2. Uses the extracted trace ID instead of generating a new one
// 3. Only injects Traceparent when one doesn't already exist
func TestTraceparentExtraction(t *testing.T) {
	compose, err := docker.ComposeSuite("docker-compose-tpclient.yml", path.Join(pathOutput, "test-suite-traceparent.log"))
	require.NoError(t, err)
	compose.Env = append(compose.Env, `OTEL_EBPF_EXECUTABLE_PATH=`, `OTEL_EBPF_OPEN_PORT=`)
	require.NoError(t, compose.Up())

	// Wait for service to be ready
	waitForTestComponents(t, "http://localhost:6000")

	// Wait for instrumentation to be ready
	t.Log("waiting for instrumentation to be ready")
	test.Eventually(t, 2*time.Minute, func(t require.TestingT) {
		ti.DoHTTPGet(t, "http://localhost:6000/smoke", 200)

		resp, err := http.Get(jaegerQueryURL + "?service=tpclient-a&limit=1")
		if err != nil || resp == nil || resp.StatusCode != http.StatusOK {
			return
		}

		var tq jaeger.TracesQuery
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&tq))
		if len(tq.Data) == 0 {
			return
		}
	}, test.Interval(1*time.Second))
	t.Log("instrumentation ready")

	t.Run("without_traceparent", testWithoutTraceparent)
	t.Run("with_traceparent", testWithTraceparent)
	t.Run("with_forwarded_traceparent", testWithForwardedTraceparent)

	require.NoError(t, compose.Close())
}

// testWithoutTraceparent validates that when NO Traceparent header is present,
// eBPF generates a new trace ID and propagates it through the chain
func testWithoutTraceparent(t *testing.T) {
	// Trigger /no-tp endpoint - starts chain: a -> b -> c
	// Each service makes client call WITHOUT traceparent (eBPF should generate and propagate)
	ti.DoHTTPGet(t, "http://localhost:6000/no-tp", 200)

	var trace jaeger.Trace
	test.Eventually(t, testTimeout, func(t require.TestingT) {
		resp, err := http.Get(jaegerQueryURL + "?service=tpclient-a&operation=GET%20%2Fno-tp")
		require.NoError(t, err)
		require.Equal(t, http.StatusOK, resp.StatusCode)

		var tq jaeger.TracesQuery
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&tq))
		traces := tq.FindBySpan(jaeger.Tag{Key: "url.path", Type: "string", Value: "/no-tp"})
		require.GreaterOrEqual(t, len(traces), 1)
		trace = traces[0]
		require.NotEmpty(t, trace.Spans)
	}, test.Interval(100*time.Millisecond))

	// Validate the trace has spans from all 3 services (a, b, c)
	serviceASpans := trace.FindByOperationName("GET /no-tp", "server")
	require.GreaterOrEqual(t, len(serviceASpans), 1)
	serviceASpan := serviceASpans[0]

	// Should have a trace ID (generated by eBPF)
	require.NotEmpty(t, serviceASpan.TraceID)
	require.Len(t, serviceASpan.TraceID, 32) // 16 bytes in hex = 32 characters

	// Should NOT be the static trace ID (since we didn't send one)
	require.NotEqual(t, staticTraceID, serviceASpan.TraceID,
		"eBPF should generate a new trace ID, not use the static one")

	// Verify all spans in the trace share the same trace ID (context propagation)
	for _, span := range trace.Spans {
		require.Equal(t, serviceASpan.TraceID, span.TraceID,
			"All spans in chain should share the same generated trace ID")
	}
}

// testWithTraceparent validates that when a Traceparent header IS present,
// eBPF extracts and uses the existing trace ID (no generation)
func testWithTraceparent(t *testing.T) {
	// Trigger /with-tp endpoint - starts chain: a -> b -> c
	// Each service makes client call WITH static traceparent (eBPF should extract and propagate)
	ti.DoHTTPGet(t, "http://localhost:6000/with-tp", 200)

	var trace jaeger.Trace
	test.Eventually(t, testTimeout, func(t require.TestingT) {
		// Query by static trace ID
		resp, err := http.Get(jaegerQueryURL + "?service=tpclient-a&traceID=" + staticTraceID)
		require.NoError(t, err)
		require.Equal(t, http.StatusOK, resp.StatusCode)

		var tq jaeger.TracesQuery
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&tq))
		require.GreaterOrEqual(t, len(tq.Data), 1, "should find trace with static trace ID")
		trace = tq.Data[0]
		require.NotEmpty(t, trace.Spans)
	}, test.Interval(100*time.Millisecond))

	// CRITICAL: All spans must have the static trace ID, proving extraction worked
	for _, span := range trace.Spans {
		require.Equal(t, staticTraceID, span.TraceID,
			"eBPF should extract and use the static Traceparent trace ID (12345...) for all spans in chain")
	}

	// Verify we have spans from all 3 services in the chain
	require.GreaterOrEqual(t, len(trace.Spans), 3,
		"Should have spans from all services in the chain (a, b, c)")
}

// testWithForwardedTraceparent validates that when the SAME Traceparent is forwarded
// unchanged through the chain (proxy scenario), eBPF detects this and overrides the span ID
func testWithForwardedTraceparent(t *testing.T) {
	// Trigger /with-forwarded-tp endpoint - starts chain: a -> b -> c
	// Each service forwards the SAME static traceparent (simulating a proxy)
	// eBPF should detect that span_id matches parent_id and override it
	ti.DoHTTPGet(t, "http://localhost:6000/with-forwarded-tp", 200)

	var trace jaeger.Trace
	test.Eventually(t, testTimeout, func(t require.TestingT) {
		// Query by static trace ID
		resp, err := http.Get(jaegerQueryURL + "?service=tpclient-a&traceID=" + staticTraceID)
		require.NoError(t, err)
		require.Equal(t, http.StatusOK, resp.StatusCode)

		var tq jaeger.TracesQuery
		require.NoError(t, json.NewDecoder(resp.Body).Decode(&tq))

		// Find traces with /with-forwarded-tp operations
		traces := tq.FindBySpan(jaeger.Tag{Key: "url.path", Type: "string", Value: "/with-forwarded-tp"})
		require.GreaterOrEqual(t, len(traces), 1, "should find trace with forwarded traceparent")
		trace = traces[0]
		require.NotEmpty(t, trace.Spans)
	}, test.Interval(100*time.Millisecond))

	// CRITICAL: All spans must have the static trace ID (extraction worked)
	for _, span := range trace.Spans {
		require.Equal(t, staticTraceID, span.TraceID,
			"eBPF should extract and use the static trace ID even for forwarded traceparents")
	}

	// CRITICAL: Span IDs should NOT all be the forwarded span ID (1111111111111111)
	// eBPF should detect the forwarding pattern and override with generated span IDs
	allSpansHaveForwardedID := true
	for _, span := range trace.Spans {
		if span.SpanID != forwardedSpanID {
			allSpansHaveForwardedID = false
			break
		}
	}
	require.False(t, allSpansHaveForwardedID,
		"eBPF should override forwarded span IDs (not all spans should have %s)", forwardedSpanID)

	// Verify we have spans from all 3 services in the chain
	require.GreaterOrEqual(t, len(trace.Spans), 3,
		"Should have spans from all services in the chain (a, b, c)")
}
