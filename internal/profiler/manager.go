package profiler
// Copyright The Telegen Authors
// SPDX-License-Identifier: Apache-2.0

























































































































































































































































































































































































































































































































































































}	return result	}		}			result = append(result, pt)		if active {	for pt, active := range m.activeProfiles {	result := make([]ProfileType, 0, len(m.activeProfiles))		defer m.mu.RUnlock()	m.mu.RLock()func (m *Manager) GetActiveProfiles() []ProfileType {// GetActiveProfiles returns the list of active profile types}	return m.diffEngine.Compare(ctx, profileType, baseline, comparison)		}		return nil, errors.New("differential profiler not initialized")	if m.diffEngine == nil {func (m *Manager) ComparePeriods(ctx context.Context, profileType ProfileType, baseline, comparison TimeRange) (*DiffResult, error) {// ComparePeriods runs differential analysis between two time periods}	return m.flameGraphGen.Generate(profile)		}		return nil, fmt.Errorf("no profile available for type: %s", profileType)	if profile == nil {	profile := m.collector.GetLatest(profileType)		}		return nil, errors.New("collector not initialized")	if m.collector == nil {		}		return nil, errors.New("flame graph generator not initialized")	if m.flameGraphGen == nil {func (m *Manager) GenerateFlameGraph(ctx context.Context, profileType ProfileType) (*FlameGraph, error) {// GenerateFlameGraph creates a flame graph from the latest profile}	}		}				"error", err)				"type", profile.Type, 			m.log.Error("failed to export profile", 		if err := m.exporter.Export(ctx, profile); err != nil {	for _, profile := range profiles {	profiles := m.collector.Drain()		}		return	if m.collector == nil || m.exporter == nil {func (m *Manager) export(ctx context.Context) {// export exports queued profiles}	}		}			m.export(ctx)		case <-ticker.C:			return		case <-m.stopCh:			return		case <-ctx.Done():		select {	for {		defer ticker.Stop()	ticker := time.NewTicker(m.config.ExportInterval)		defer m.wg.Done()func (m *Manager) exportLoop(ctx context.Context) {// exportLoop periodically exports collected profiles}	}		m.collector.Add(profile)	if m.collector != nil {	// Queue for export		}		}			m.log.Error("failed to store profile", "error", err)		if err := m.storage.Store(ctx, profile); err != nil {	if m.storage != nil {	// Store for differential analysisfunc (m *Manager) handleProfile(ctx context.Context, profile *Profile) {// handleProfile processes a collected profile}	}		}			m.handleProfile(ctx, profile)		} else if profile != nil {			m.log.Error("failed to collect mutex profile", "error", err)		if profile, err := m.mutexProfiler.Collect(ctx); err != nil {	if m.mutexProfiler != nil && m.activeProfiles[ProfileTypeMutex] {		}		}			}				m.handleProfile(ctx, profile)			} else if profile != nil {				m.log.Error("failed to collect heap profile", "error", err)			if profile, err := m.memProfiler.CollectHeap(ctx); err != nil {		if m.activeProfiles[ProfileTypeHeap] {	if m.memProfiler != nil {		}		}			m.handleProfile(ctx, profile)		} else if profile != nil {			m.log.Error("failed to collect off-CPU profile", "error", err)		if profile, err := m.offCPUProfiler.Collect(ctx); err != nil {	if m.offCPUProfiler != nil && m.activeProfiles[ProfileTypeOffCPU] {		}		}			m.handleProfile(ctx, profile)		} else if profile != nil {			m.log.Error("failed to collect CPU profile", "error", err)		if profile, err := m.cpuProfiler.Collect(ctx); err != nil {	if m.cpuProfiler != nil && m.activeProfiles[ProfileTypeCPU] {		defer m.mu.RUnlock()	m.mu.RLock()func (m *Manager) collect(ctx context.Context) {// collect collects profiles from all active profilers}	}		}			m.collect(ctx)		case <-ticker.C:			return		case <-m.stopCh:			return		case <-ctx.Done():		select {	for {		defer ticker.Stop()	ticker := time.NewTicker(m.config.CollectInterval)		defer m.wg.Done()func (m *Manager) collectionLoop(ctx context.Context) {// collectionLoop periodically collects profiles from eBPF}	}		return fmt.Errorf("unsupported profile type: %s", pt)	default:				return profiler.Start(ctx)		m.mutexProfiler = profiler		}			return err		if err != nil {		profiler, err := NewMutexProfiler(m.config, m.log)	case ProfileTypeMutex:				return nil		}			return profiler.Start(ctx)			m.memProfiler = profiler			}				return err			if err != nil {			profiler, err := NewMemoryProfiler(m.config, m.log)		if m.memProfiler == nil {	case ProfileTypeAllocBytes, ProfileTypeAllocCount, ProfileTypeHeap:				return profiler.Start(ctx)		m.wallProfiler = profiler		}			return err		if err != nil {		profiler, err := NewWallProfiler(m.config, m.log)	case ProfileTypeWall:				return profiler.Start(ctx)		m.offCPUProfiler = profiler		}			return err		if err != nil {		profiler, err := NewOffCPUProfiler(m.config, m.log)	case ProfileTypeOffCPU:				return profiler.Start(ctx)		m.cpuProfiler = profiler		}			return err		if err != nil {		profiler, err := NewCPUProfiler(m.config, m.log)	case ProfileTypeCPU:	switch pt {func (m *Manager) startProfiler(ctx context.Context, pt ProfileType) error {// startProfiler starts a specific profiler type}	m.storage = storage	defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) SetStorage(storage ProfileStorage) {// SetStorage sets the profile storage}	m.exporter = exporter	defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) SetExporter(exporter ProfileExporter) {// SetExporter sets the profile exporter}	return nil		}		m.storage.Close()	if m.storage != nil {	}		m.exporter.Close()	if m.exporter != nil {	}		m.symbolResolver.Close()	if m.symbolResolver != nil {	// Close resources		}		m.mutexProfiler.Stop()	if m.mutexProfiler != nil {	}		m.memProfiler.Stop()	if m.memProfiler != nil {	}		m.wallProfiler.Stop()	if m.wallProfiler != nil {	}		m.offCPUProfiler.Stop()	if m.offCPUProfiler != nil {	}		m.cpuProfiler.Stop()	if m.cpuProfiler != nil {	// Stop profilers		m.wg.Wait()	close(m.stopCh)		m.log.Info("stopping profiler manager")		m.mu.Unlock()	m.running = false	}		return nil		m.mu.Unlock()	if !m.running {	m.mu.Lock()func (m *Manager) Stop() error {// Stop gracefully stops all profilers}	return nil		}		go m.exportLoop(ctx)		m.wg.Add(1)	if m.exporter != nil {	// Start export loop		go m.collectionLoop(ctx)	m.wg.Add(1)	// Start collection loop		m.running = true		}		m.log.Info("started profiler", "type", pt)		m.activeProfiles[pt] = true		}			continue			m.log.Error("failed to start profiler", "type", pt, "error", err)		if err := m.startProfiler(ctx, pt); err != nil {	for _, pt := range m.config.EnabledProfiles {	// Start enabled profilers		}		m.diffEngine = NewDifferentialProfiler(m.config.Differential, m.storage, m.log)	if m.config.Differential.Enabled && m.storage != nil {	// Initialize differential profiler if enabled		m.collector = NewCollector(m.config, m.symbolResolver, m.log)	// Initialize collector		m.flameGraphGen = NewFlameGraphGenerator(m.config.FlameGraph, m.log)	// Initialize flame graph generator		}		return fmt.Errorf("failed to create symbol resolver: %w", err)	if err != nil {	m.symbolResolver, err = NewSymbolResolver(m.log)	var err error	// Initialize symbol resolver			"sample_rate", m.config.SampleRate)		"enabled_profiles", m.config.EnabledProfiles,	m.log.Info("starting profiler manager", 		}		return errors.New("profiler manager already running")	if m.running {		defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) Start(ctx context.Context) error {// Start initializes and starts all enabled profilers}	}, nil		stopCh:         make(chan struct{}),		activeProfiles: make(map[ProfileType]bool),		log:            log.With("component", "profiler"),		config:         cfg,	return &Manager{		}		log = slog.Default()	if log == nil {func New(cfg Config, log *slog.Logger) (*Manager, error) {// New creates a new profiler manager}	End   time.Time	Start time.Timetype TimeRange struct {// TimeRange represents a time window}	Close() error	Delete(ctx context.Context, before time.Time) error	Query(ctx context.Context, profileType ProfileType, timeRange TimeRange) ([]*Profile, error)	Store(ctx context.Context, profile *Profile) errortype ProfileStorage interface {// ProfileStorage provides persistent storage for profiles}	Close() error	Export(ctx context.Context, profile *Profile) errortype ProfileExporter interface {// ProfileExporter exports profiles to external systems}	wg             sync.WaitGroup	stopCh         chan struct{}	running        bool	activeProfiles map[ProfileType]bool	mu             sync.RWMutex	// State		storage        ProfileStorage	exporter       ProfileExporter	collector      *Collector	diffEngine     *DifferentialProfiler	flameGraphGen  *FlameGraphGenerator	symbolResolver *SymbolResolver	// Userspace components		mutexProfiler  *MutexProfiler	memProfiler    *MemoryProfiler	wallProfiler   *WallProfiler	offCPUProfiler *OffCPUProfiler	cpuProfiler    *CPUProfiler	// eBPF profilers		log            *slog.Logger	config         Configtype Manager struct {// Manager manages all profiling subsystems}	}		},			BaselineStrategy: BaselineStrategyRolling,			Threshold:        10.0, // 10% change threshold			ComparisonWindow: 10 * time.Minute,			BaselineWindow:   1 * time.Hour,			Enabled:          true,		Differential: DifferentialConfig{		},			MinWidth:    0.1,			ColorScheme: ColorSchemeHot,			Format:      FlameGraphFormatHTML,		FlameGraph: FlameGraphConfig{		ContentionThresholdNs: 1_000_000,  // 1ms		MinAllocSize:          0,          // Track all allocations		MinBlockTimeNs:        1_000_000,  // 1ms		},			ProfileTypeHeap,			ProfileTypeAllocBytes,			ProfileTypeOffCPU,			ProfileTypeCPU,		EnabledProfiles: []ProfileType{		StorageRetention: 7 * 24 * time.Hour, // 7 days for differential		CollectInterval: 1 * time.Second,		ExportInterval:  10 * time.Second,		SampleRate:      99, // 99 Hz to avoid lockstep with other sampling		Enabled:         true,	return Config{func DefaultConfig() Config {// DefaultConfig returns default profiler configuration)	BaselineStrategyManual     BaselineStrategy = "manual"	BaselineStrategyTimeOfDay  BaselineStrategy = "time_of_day"	BaselineStrategyDeployment BaselineStrategy = "deployment"	BaselineStrategyRolling    BaselineStrategy = "rolling"	BaselineStrategyPrevious   BaselineStrategy = "previous"const (type BaselineStrategy string// BaselineStrategy determines how to select baseline for comparison}	BaselineStrategy BaselineStrategy `mapstructure:"baseline_strategy"`	// BaselineStrategy determines how baseline is selected	Threshold float64 `mapstructure:"threshold"`	// Threshold is the percentage change to trigger alerts	ComparisonWindow time.Duration `mapstructure:"comparison_window"`	// ComparisonWindow is the duration of the comparison period	BaselineWindow time.Duration `mapstructure:"baseline_window"`	// BaselineWindow is the duration of the baseline period	Enabled bool `mapstructure:"enabled"`	// Enabled controls differential analysistype DifferentialConfig struct {// DifferentialConfig holds differential profiling settings}	MinWidth float64 `mapstructure:"min_width"`	// MinWidth is the minimum percentage width to show	Title string `mapstructure:"title"`	// Title for the flame graph	ColorScheme ColorScheme `mapstructure:"color_scheme"`	// ColorScheme for visualization	Format FlameGraphFormat `mapstructure:"format"`	// Format for output (html, svg, json, collapsed, pprof)type FlameGraphConfig struct {// FlameGraphConfig holds flame graph generation settings}	Differential DifferentialConfig `mapstructure:"differential"`	// Differential profiling configuration	FlameGraph FlameGraphConfig `mapstructure:"flamegraph"`	// FlameGraph configuration	ContentionThresholdNs uint64 `mapstructure:"contention_threshold_ns"`	// ContentionThresholdNs is the minimum mutex wait time to record	MinAllocSize uint64 `mapstructure:"min_alloc_size"`	// MinAllocSize is the minimum allocation size to track	MinBlockTimeNs uint64 `mapstructure:"min_block_time_ns"`	// MinBlockTimeNs is the minimum off-CPU time to record (nanoseconds)	TargetContainers []string `mapstructure:"target_containers"`	// TargetContainers limits profiling to specific container IDs	TargetPIDs []uint32 `mapstructure:"target_pids"`	// TargetPIDs limits profiling to specific PIDs (empty = all)	EnabledProfiles []ProfileType `mapstructure:"enabled_profiles"`	// EnabledProfiles lists which profile types are active	StorageRetention time.Duration `mapstructure:"storage_retention"`	// StorageRetention is how long to keep profiles for differential analysis	CollectInterval time.Duration `mapstructure:"collect_interval"`	// CollectInterval is how often to collect from eBPF maps	ExportInterval time.Duration `mapstructure:"export_interval"`	// ExportInterval is how often to export collected profiles	SampleRate int `mapstructure:"sample_rate"`	// SampleRate is the sampling frequency in Hz for CPU profiling	Enabled bool `mapstructure:"enabled"`	// Enabled controls whether profiling is activetype Config struct {// Config holds profiler configuration}	}		return "unknown"	default:		return "runnable"	case BlockReasonRunnable:		return "preempted"	case BlockReasonPreempted:		return "epoll"	case BlockReasonEpoll:		return "futex"	case BlockReasonFutex:		return "page_fault"	case BlockReasonPage:		return "network"	case BlockReasonNet:		return "sleep"	case BlockReasonSleep:		return "lock"	case BlockReasonLock:		return "io"	case BlockReasonIO:	switch r {func (r BlockReason) String() string {)	BlockReasonRunnable  BlockReason = 9	BlockReasonPreempted BlockReason = 8	BlockReasonEpoll     BlockReason = 7	BlockReasonFutex     BlockReason = 6	BlockReasonPage      BlockReason = 5	BlockReasonNet       BlockReason = 4	BlockReasonSleep     BlockReason = 3	BlockReasonLock      BlockReason = 2	BlockReasonIO        BlockReason = 1	BlockReasonUnknown   BlockReason = 0const (type BlockReason uint8// BlockReason represents why a thread was blocked)	ProfileTypeException  ProfileType = "exception"	ProfileTypeNetIO      ProfileType = "net_io"	ProfileTypeDiskIO     ProfileType = "disk_io"	ProfileTypeGoroutine  ProfileType = "goroutine"	ProfileTypeBlock      ProfileType = "block"	ProfileTypeMutex      ProfileType = "mutex"	ProfileTypeHeap       ProfileType = "heap"	ProfileTypeAllocBytes ProfileType = "alloc_bytes"	ProfileTypeAllocCount ProfileType = "allocs"	ProfileTypeWall       ProfileType = "wall"	ProfileTypeOffCPU     ProfileType = "offcpu"	ProfileTypeCPU        ProfileType = "cpu"const (type ProfileType string// ProfileType represents different profiling modes)	"time"	"sync"	"log/slog"	"fmt"	"errors"	"context"import (package profiler// mutex contention, and off-CPU analysis using eBPF.// Package profiler provides continuous profiling capabilities for CPU, memory,