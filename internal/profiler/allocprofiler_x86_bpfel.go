// Code generated by bpf2go; DO NOT EDIT.
//go:build linux && (386 || amd64)

package profiler

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type AllocProfilerAllocConfig struct {
	_            structs.HostLayout
	TargetPid    uint32
	_            [4]byte
	MinSize      uint64
	SampleRate   uint64
	TrackFree    uint8
	TrackCalloc  uint8
	TrackRealloc uint8
	TrackMmap    uint8
	FilterActive uint8
	Pad          [3]uint8
}

type AllocProfilerAllocInfo struct {
	_           structs.HostLayout
	Size        uint64
	TimestampNs uint64
	StackId     int32
	Pid         uint32
	Tid         uint32
	AllocType   uint8
	Pad         [3]uint8
}

type AllocProfilerAllocKey struct {
	_         structs.HostLayout
	StackId   int32
	AllocType uint8
	Pad       [3]uint8
}

type AllocProfilerAllocStats struct {
	_               structs.HostLayout
	TotalBytes      uint64
	AllocCount      uint64
	FreeCount       uint64
	CurrentBytes    uint64
	CurrentCount    uint64
	MaxBytes        uint64
	TotalLifetimeNs uint64
}

type AllocProfilerPendingAlloc struct {
	_         structs.HostLayout
	Size      uint64
	StartNs   uint64
	StackId   int32
	AllocType uint8
	Pad       [3]uint8
}

type AllocProfilerPendingRealloc struct {
	_       structs.HostLayout
	OldAddr uint64
	NewSize uint64
	StartNs uint64
	StackId int32
	Pad     int32
}

// LoadAllocProfiler returns the embedded CollectionSpec for AllocProfiler.
func LoadAllocProfiler() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_AllocProfilerBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load AllocProfiler: %w", err)
	}

	return spec, err
}

// LoadAllocProfilerObjects loads AllocProfiler and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*AllocProfilerObjects
//	*AllocProfilerPrograms
//	*AllocProfilerMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadAllocProfilerObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadAllocProfiler()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// AllocProfilerSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AllocProfilerSpecs struct {
	AllocProfilerProgramSpecs
	AllocProfilerMapSpecs
	AllocProfilerVariableSpecs
}

// AllocProfilerProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AllocProfilerProgramSpecs struct {
	TraceCallocEnter  *ebpf.ProgramSpec `ebpf:"trace_calloc_enter"`
	TraceCallocExit   *ebpf.ProgramSpec `ebpf:"trace_calloc_exit"`
	TraceFree         *ebpf.ProgramSpec `ebpf:"trace_free"`
	TraceMallocEnter  *ebpf.ProgramSpec `ebpf:"trace_malloc_enter"`
	TraceMallocExit   *ebpf.ProgramSpec `ebpf:"trace_malloc_exit"`
	TraceMmapEnter    *ebpf.ProgramSpec `ebpf:"trace_mmap_enter"`
	TraceMunmap       *ebpf.ProgramSpec `ebpf:"trace_munmap"`
	TraceReallocEnter *ebpf.ProgramSpec `ebpf:"trace_realloc_enter"`
	TraceReallocExit  *ebpf.ProgramSpec `ebpf:"trace_realloc_exit"`
}

// AllocProfilerMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AllocProfilerMapSpecs struct {
	AllocCfg           *ebpf.MapSpec `ebpf:"alloc_cfg"`
	AllocEvents        *ebpf.MapSpec `ebpf:"alloc_events"`
	AllocSampleCounter *ebpf.MapSpec `ebpf:"alloc_sample_counter"`
	AllocStacks        *ebpf.MapSpec `ebpf:"alloc_stacks"`
	AllocStatsMap      *ebpf.MapSpec `ebpf:"alloc_stats_map"`
	AllocTargetPids    *ebpf.MapSpec `ebpf:"alloc_target_pids"`
	DebugEvents        *ebpf.MapSpec `ebpf:"debug_events"`
	LiveAllocs         *ebpf.MapSpec `ebpf:"live_allocs"`
	MsgBufferMem       *ebpf.MapSpec `ebpf:"msg_buffer_mem"`
	PendingAllocs      *ebpf.MapSpec `ebpf:"pending_allocs"`
	PendingReallocs    *ebpf.MapSpec `ebpf:"pending_reallocs"`
	PidCache           *ebpf.MapSpec `ebpf:"pid_cache"`
	ValidPids          *ebpf.MapSpec `ebpf:"valid_pids"`
}

// AllocProfilerVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type AllocProfilerVariableSpecs struct {
	FilterPids              *ebpf.VariableSpec `ebpf:"filter_pids"`
	G_bpfDebug              *ebpf.VariableSpec `ebpf:"g_bpf_debug"`
	G_bpfHeaderPropagation  *ebpf.VariableSpec `ebpf:"g_bpf_header_propagation"`
	G_bpfTraceparentEnabled *ebpf.VariableSpec `ebpf:"g_bpf_traceparent_enabled"`
	Ip4ip6Prefix            *ebpf.VariableSpec `ebpf:"ip4ip6_prefix"`
	Unused                  *ebpf.VariableSpec `ebpf:"unused"`
	UnusedHttp2             *ebpf.VariableSpec `ebpf:"unused_http2"`
}

// AllocProfilerObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadAllocProfilerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AllocProfilerObjects struct {
	AllocProfilerPrograms
	AllocProfilerMaps
	AllocProfilerVariables
}

func (o *AllocProfilerObjects) Close() error {
	return _AllocProfilerClose(
		&o.AllocProfilerPrograms,
		&o.AllocProfilerMaps,
	)
}

// AllocProfilerMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadAllocProfilerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AllocProfilerMaps struct {
	AllocCfg           *ebpf.Map `ebpf:"alloc_cfg"`
	AllocEvents        *ebpf.Map `ebpf:"alloc_events"`
	AllocSampleCounter *ebpf.Map `ebpf:"alloc_sample_counter"`
	AllocStacks        *ebpf.Map `ebpf:"alloc_stacks"`
	AllocStatsMap      *ebpf.Map `ebpf:"alloc_stats_map"`
	AllocTargetPids    *ebpf.Map `ebpf:"alloc_target_pids"`
	DebugEvents        *ebpf.Map `ebpf:"debug_events"`
	LiveAllocs         *ebpf.Map `ebpf:"live_allocs"`
	MsgBufferMem       *ebpf.Map `ebpf:"msg_buffer_mem"`
	PendingAllocs      *ebpf.Map `ebpf:"pending_allocs"`
	PendingReallocs    *ebpf.Map `ebpf:"pending_reallocs"`
	PidCache           *ebpf.Map `ebpf:"pid_cache"`
	ValidPids          *ebpf.Map `ebpf:"valid_pids"`
}

func (m *AllocProfilerMaps) Close() error {
	return _AllocProfilerClose(
		m.AllocCfg,
		m.AllocEvents,
		m.AllocSampleCounter,
		m.AllocStacks,
		m.AllocStatsMap,
		m.AllocTargetPids,
		m.DebugEvents,
		m.LiveAllocs,
		m.MsgBufferMem,
		m.PendingAllocs,
		m.PendingReallocs,
		m.PidCache,
		m.ValidPids,
	)
}

// AllocProfilerVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadAllocProfilerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AllocProfilerVariables struct {
	FilterPids              *ebpf.Variable `ebpf:"filter_pids"`
	G_bpfDebug              *ebpf.Variable `ebpf:"g_bpf_debug"`
	G_bpfHeaderPropagation  *ebpf.Variable `ebpf:"g_bpf_header_propagation"`
	G_bpfTraceparentEnabled *ebpf.Variable `ebpf:"g_bpf_traceparent_enabled"`
	Ip4ip6Prefix            *ebpf.Variable `ebpf:"ip4ip6_prefix"`
	Unused                  *ebpf.Variable `ebpf:"unused"`
	UnusedHttp2             *ebpf.Variable `ebpf:"unused_http2"`
}

// AllocProfilerPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadAllocProfilerObjects or ebpf.CollectionSpec.LoadAndAssign.
type AllocProfilerPrograms struct {
	TraceCallocEnter  *ebpf.Program `ebpf:"trace_calloc_enter"`
	TraceCallocExit   *ebpf.Program `ebpf:"trace_calloc_exit"`
	TraceFree         *ebpf.Program `ebpf:"trace_free"`
	TraceMallocEnter  *ebpf.Program `ebpf:"trace_malloc_enter"`
	TraceMallocExit   *ebpf.Program `ebpf:"trace_malloc_exit"`
	TraceMmapEnter    *ebpf.Program `ebpf:"trace_mmap_enter"`
	TraceMunmap       *ebpf.Program `ebpf:"trace_munmap"`
	TraceReallocEnter *ebpf.Program `ebpf:"trace_realloc_enter"`
	TraceReallocExit  *ebpf.Program `ebpf:"trace_realloc_exit"`
}

func (p *AllocProfilerPrograms) Close() error {
	return _AllocProfilerClose(
		p.TraceCallocEnter,
		p.TraceCallocExit,
		p.TraceFree,
		p.TraceMallocEnter,
		p.TraceMallocExit,
		p.TraceMmapEnter,
		p.TraceMunmap,
		p.TraceReallocEnter,
		p.TraceReallocExit,
	)
}

func _AllocProfilerClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed allocprofiler_x86_bpfel.o
var _AllocProfilerBytes []byte
