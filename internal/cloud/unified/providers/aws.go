package providers
package providers

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"








































































































































































































































































































































var _ unified.CloudProvider = (*AWSProvider)(nil)// Ensure AWSProvider implements CloudProvider}	return tags	}		tags[key] = value		value := p.getMetadataValue(ctx, "tags/instance/"+key)		}			continue		if key == "" {		key = strings.TrimSpace(key)	for _, key := range strings.Split(tagKeys, "\n") {	// Get each tag	}		return tags	if tagKeys == "" {	tagKeys := p.getMetadataValue(ctx, "tags/instance")	// Check if tags are enabled in IMDS	tags := make(map[string]string)func (p *AWSProvider) getInstanceTags(ctx context.Context) map[string]string {// getInstanceTags retrieves instance tags (if IMDS tags are enabled).}	return strings.TrimSpace(string(body))	}		return ""	if err != nil {	body, err := io.ReadAll(resp.Body)	}		return ""	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return ""	if err != nil {	resp, err := p.client.Do(req)	req.Header.Set("X-aws-ec2-metadata-token", p.token)	}		return ""	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)	url := endpoint + awsIMDSMetadataPath + path	}		endpoint = awsIMDSEndpoint	if endpoint == "" {	endpoint := p.config.IMDSEndpointfunc (p *AWSProvider) getMetadataValue(ctx context.Context, path string) string {// getMetadataValue retrieves a single metadata value.}	return &doc, nil	}		return nil, err	if err := json.NewDecoder(resp.Body).Decode(&doc); err != nil {	var doc awsInstanceIdentityDocument	}		return nil, fmt.Errorf("failed to get identity document: status %d", resp.StatusCode)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return nil, err	if err != nil {	resp, err := p.client.Do(req)	req.Header.Set("X-aws-ec2-metadata-token", p.token)	}		return nil, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint+awsIMDSDynamicPath, nil)	}		endpoint = awsIMDSEndpoint	if endpoint == "" {	endpoint := p.config.IMDSEndpointfunc (p *AWSProvider) getInstanceIdentityDocument(ctx context.Context) (*awsInstanceIdentityDocument, error) {// getInstanceIdentityDocument retrieves the instance identity document.}	Version          string `json:"version"`	Region           string `json:"region"`	PrivateIP        string `json:"privateIp"`	InstanceType     string `json:"instanceType"`	InstanceID       string `json:"instanceId"`	ImageID          string `json:"imageId"`	AvailabilityZone string `json:"availabilityZone"`	Architecture     string `json:"architecture"`	AccountID        string `json:"accountId"`type awsInstanceIdentityDocument struct {// awsInstanceIdentityDocument represents the instance identity document.}	return nil	p.tokenExpiry = time.Now().Add(6 * time.Hour)	p.token = token	}		return err	if err != nil {	token, err := p.getToken(ctx)	}		return nil	if p.token != "" && time.Now().Before(p.tokenExpiry) {func (p *AWSProvider) ensureToken(ctx context.Context) error {// ensureToken ensures we have a valid token.}	return string(body), nil	}		return "", err	if err != nil {	body, err := io.ReadAll(resp.Body)	}		return "", fmt.Errorf("failed to get token: status %d", resp.StatusCode)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return "", err	if err != nil {	resp, err := p.client.Do(req)	req.Header.Set("X-aws-ec2-metadata-token-ttl-seconds", "21600") // 6 hours	}		return "", err	if err != nil {	req, err := http.NewRequestWithContext(ctx, http.MethodPut, endpoint+awsIMDSTokenPath, nil)	}		endpoint = awsIMDSEndpoint	if endpoint == "" {	endpoint := p.config.IMDSEndpointfunc (p *AWSProvider) getToken(ctx context.Context) (string, error) {// getToken retrieves an IMDSv2 token.}	return nil	}		return fmt.Errorf("IMDS health check failed: %w", err)	if err := p.ensureToken(ctx); err != nil {func (p *AWSProvider) HealthCheck(ctx context.Context) error {// HealthCheck verifies IMDS connectivity.}	}, nil		},			},				"subnet_id":     meta.Subnet,				"vpc_id":        meta.VPC,				"ami_id":        meta.ImageID,				"instance_type": meta.InstanceType,			Attributes: map[string]any{			Tags:             meta.Tags,			Status:           "running",			AvailabilityZone: meta.AvailabilityZone,			Region:           meta.Region,			Provider:         "aws",			Type:             unified.ResourceTypeVM,			Name:             meta.InstanceName,			ID:               meta.InstanceID,		{	return []unified.Resource{	// Return the local instance as a resource	}		return nil, err	if err != nil {	meta, err := p.GetMetadata(ctx)func (p *AWSProvider) DiscoverResources(ctx context.Context) ([]unified.Resource, error) {// This provides the local instance as a resource.// Note: For full resource discovery, use the AWS SDK.// DiscoverResources discovers AWS resources.}	return []unified.Metric{}, nil		// Here we can provide instance metadata as metrics.	// CloudWatch integration would be done separately.	// IMDS doesn't provide many metrics directly.func (p *AWSProvider) CollectMetrics(ctx context.Context) ([]unified.Metric, error) {// This provides basic IMDS-available metrics.// Note: For detailed CloudWatch metrics, use the AWS SDK.// CollectMetrics collects AWS-specific metrics.}	}, nil		LastUpdated:      time.Now(),		DetectedAt:       time.Now(),		DetectionMethod:  "imdsv2",		Tags:             tags,		IsContainer:      false, // Will be updated by container detection		IsVM:             true,		Architecture:     doc.Architecture,		ImageID:          ami,		Subnet:           subnetID,		VPC:              vpcID,		MAC:              mac,		PublicIP:         publicIP,		PrivateIP:        privateIP,		Hostname:         hostname,		InstanceType:     instanceType,		InstanceName:     tags["Name"],		InstanceID:       doc.InstanceID,		AccountID:        doc.AccountID,		AvailabilityZone: doc.AvailabilityZone,		Region:           doc.Region,		ProviderType:     unified.CloudTypePublic,		Provider:         "aws",	return &unified.CloudMetadata{	tags := p.getInstanceTags(ctx)	// Get instance tags (if enabled)	}		subnetID = p.getMetadataValue(ctx, fmt.Sprintf("network/interfaces/macs/%s/subnet-id", mac))		vpcID = p.getMetadataValue(ctx, fmt.Sprintf("network/interfaces/macs/%s/vpc-id", mac))	if mac != "" {	subnetID := ""	vpcID := ""	// Get VPC info from network interface	ami := p.getMetadataValue(ctx, "ami-id")	instanceType := p.getMetadataValue(ctx, "instance-type")	mac := p.getMetadataValue(ctx, "mac")	privateIP := p.getMetadataValue(ctx, "local-ipv4")	publicIP := p.getMetadataValue(ctx, "public-ipv4")	hostname := p.getMetadataValue(ctx, "hostname")	// Get additional metadata	}		return nil, fmt.Errorf("failed to get instance identity: %w", err)	if err != nil {	doc, err := p.getInstanceIdentityDocument(ctx)	// Get instance identity document	}		return nil, fmt.Errorf("failed to get IMDS token: %w", err)	if err := p.ensureToken(ctx); err != nil {	// Ensure we have a valid tokenfunc (p *AWSProvider) GetMetadata(ctx context.Context) (*unified.CloudMetadata, error) {// GetMetadata retrieves AWS EC2 instance metadata.}	return true, nil	p.tokenExpiry = time.Now().Add(6 * time.Hour)	p.token = token	}		return false, nil // Not on AWS or IMDS not available	if err != nil {	token, err := p.getToken(ctx)	// Try to get IMDSv2 tokenfunc (p *AWSProvider) Detect(ctx context.Context) (bool, error) {// Detect checks if running on AWS EC2.}	return awsPriorityfunc (p *AWSProvider) Priority() int {// Priority returns the detection priority.}	return unified.CloudTypePublicfunc (p *AWSProvider) Type() unified.CloudType {// Type returns the cloud type.}	return "aws"func (p *AWSProvider) Name() string {// Name returns the provider name.}	}		},			},				DisableKeepAlives: true,			Transport: &http.Transport{			Timeout: timeout,		client: &http.Client{		config: config,	return &AWSProvider{	}		timeout = 2 * time.Second	if timeout == 0 {	timeout := config.IMDSTimeout	}		config = unified.DefaultAWSConfig()	if config == nil {func NewAWSProvider(config *unified.AWSConfig) *AWSProvider {// NewAWSProvider creates a new AWS cloud provider.}	tokenExpiry time.Time	token  string	client *http.Client	config *unified.AWSConfigtype AWSProvider struct {// AWSProvider implements CloudProvider for Amazon Web Services.)	awsPriority = 1	// AWS provider priority (public cloud, highest)	awsIMDSDynamicPath   = "/latest/dynamic/instance-identity/document"	awsIMDSMetadataPath  = "/latest/meta-data/"	awsIMDSTokenPath     = "/latest/api/token"	awsIMDSEndpoint      = "http://169.254.169.254"	// AWS IMDS endpointsconst ()	"github.com/platformbuilds/telegen/internal/cloud/unified"	"time"	"strings"