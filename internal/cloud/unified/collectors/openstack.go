package collectors
package collectors

import (
	"context"
	"encoding/json"
	"fmt"












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































}	}		},			return result, nil			}				result = result*10 + int64(c-'0')				}					return 0, fmt.Errorf("invalid number")				if c < '0' || c > '9' {			for _, c := range s {			var result int64		ParseInt: func(s string, base int, bitSize int) (int64, error) {		},			return result, nil			}				result = result*10 + int(c-'0')				}					return 0, fmt.Errorf("invalid number")				if c < '0' || c > '9' {			for _, c := range s {			var result int		Atoi: func(s string) (int, error) {	}{		ParseInt func(string, int, int) (int64, error)		Atoi     func(string) (int, error)	return struct {} {	ParseInt func(string, int, int) (int64, error)	Atoi     func(string) (int, error)func strconv() struct {// strconv helper for Swift metrics.}	Name string `json:"name"`	ID   string `json:"id"`type neutronSecurityGroup struct {}	SecurityGroups []neutronSecurityGroup `json:"security_groups"`type neutronSecurityGroupsResponse struct {}	Status string `json:"status"`	Name   string `json:"name"`	ID     string `json:"id"`type neutronPort struct {}	Ports []neutronPort `json:"ports"`type neutronPortsResponse struct {}	Status            string `json:"status"`	PortID            string `json:"port_id"`	FloatingIPAddress string `json:"floating_ip_address"`	ID                string `json:"id"`type neutronFloatingIP struct {}	FloatingIPs []neutronFloatingIP `json:"floatingips"`type neutronFloatingIPsResponse struct {}	Status string `json:"status"`	Name   string `json:"name"`	ID     string `json:"id"`type neutronRouter struct {}	Routers []neutronRouter `json:"routers"`type neutronRoutersResponse struct {}	MTU                 int      `json:"mtu"`	Subnets             []string `json:"subnets"`	ProviderNetworkType string   `json:"provider:network_type"`	External            bool     `json:"router:external"`	Shared              bool     `json:"shared"`	AdminStateUp        bool     `json:"admin_state_up"`	Status              string   `json:"status"`	Name                string   `json:"name"`	ID                  string   `json:"id"`type neutronNetwork struct {}	Networks []neutronNetwork `json:"networks"`type neutronNetworksResponse struct {// Neutron response structures.}	VolumeID string `json:"volume_id"`	Size     int    `json:"size"`	Status   string `json:"status"`	Name     string `json:"name"`	ID       string `json:"id"`type cinderSnapshot struct {}	Snapshots []cinderSnapshot `json:"snapshots"`type cinderSnapshotsResponse struct {}	Metadata         map[string]string `json:"metadata"`	Attachments      []any             `json:"attachments"`	CreatedAt        string            `json:"created_at"`	AvailabilityZone string            `json:"availability_zone"`	VolumeType       string            `json:"volume_type"`	Size             int               `json:"size"`	Status           string            `json:"status"`	Name             string            `json:"name"`	ID               string            `json:"id"`type cinderVolume struct {}	Volumes []cinderVolume `json:"volumes"`type cinderVolumesResponse struct {// Cinder response structures.}	Metadata         map[string]string `json:"metadata"`	Addresses        map[string]any    `json:"addresses"`	Flavor           map[string]any    `json:"flavor"`	Updated          string            `json:"updated"`	Created          string            `json:"created"`	AvailabilityZone string            `json:"OS-EXT-AZ:availability_zone"`	HostID           string            `json:"hostId"`	UserID           string            `json:"user_id"`	TenantID         string            `json:"tenant_id"`	Status           string            `json:"status"`	Name             string            `json:"name"`	ID               string            `json:"id"`type novaServer struct {}	Servers []novaServer `json:"servers"`type novaServersResponse struct {}	RunningVMs   int    `json:"running_vms"`	LocalGBUsed  int    `json:"local_gb_used"`	LocalGB      int    `json:"local_gb"`	MemoryMBUsed int    `json:"memory_mb_used"`	MemoryMB     int    `json:"memory_mb"`	VCPUsUsed    int    `json:"vcpus_used"`	VCPUs        int    `json:"vcpus"`	Status       string `json:"status"`	State        string `json:"state"`	Type         string `json:"hypervisor_type"`	Name         string `json:"hypervisor_hostname"`	ID           string `json:"id"`type novaHypervisor struct {}	Hypervisors []novaHypervisor `json:"hypervisors"`type novaHypervisorsResponse struct {// Nova response structures.}	Region    string `json:"region"`	Interface string `json:"interface"`	URL       string `json:"url"`type keystoneEndpoint struct {}	Endpoints []keystoneEndpoint `json:"endpoints"`	Name      string             `json:"name"`	Type      string             `json:"type"`type keystoneService struct {}	Catalog   []keystoneService `json:"catalog"`	ExpiresAt string            `json:"expires_at"`type keystoneToken struct {}	Token keystoneToken `json:"token"`type keystoneAuthResponse struct {}	Domain keystoneDomain `json:"domain"`	Name   string         `json:"name"`type keystoneProject struct {}	Project keystoneProject `json:"project"`type keystoneScope struct {}	Name string `json:"name"`type keystoneDomain struct {}	Domain   keystoneDomain `json:"domain"`	Password string         `json:"password"`	Name     string         `json:"name"`type keystoneUser struct {}	User keystoneUser `json:"user"`type keystonePassword struct {}	Password keystonePassword `json:"password"`	Methods  []string         `json:"methods"`type keystoneIdentity struct {}	Scope    keystoneScope    `json:"scope"`	Identity keystoneIdentity `json:"identity"`type keystoneAuth struct {}	Auth keystoneAuth `json:"auth"`type keystoneAuthRequest struct {// Keystone authentication structures.}	return n, nil	r.pos += n	n = copy(p, r.data[r.pos:])	}		return 0, io.EOF	if r.pos >= len(r.data) {func (r *bytesReader) Read(p []byte) (n int, err error) {}	pos  int	data []bytetype bytesReader struct {}	return &bytesReader{data: b}func newBytesReader(b []byte) io.Reader {// Helper to create a reader from bytes.}	return io.ReadAll(resp.Body)	}		return nil, fmt.Errorf("request failed: %s", resp.Status)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return nil, err	if err != nil {	resp, err := c.client.Do(req)	c.mu.RUnlock()	req.Header.Set("X-Auth-Token", c.token)	c.mu.RLock()	}		return nil, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)func (c *OpenStackCollector) doRequest(ctx context.Context, url string) ([]byte, error) {// doRequest performs an authenticated HTTP request.}	return resources, nil	}		resources = append(resources, resource)		}			},				"mtu":                   net.MTU,				"subnets":               net.Subnets,				"provider_network_type": net.ProviderNetworkType,				"external":              net.External,				"shared":                net.Shared,				"admin_state_up":        net.AdminStateUp,			Properties: map[string]any{			Status:   net.Status,			Region:   c.config.Region,			Provider: "openstack",			Type:     unified.ResourceTypeNetwork,			Name:     net.Name,			ID:       net.ID,		resource := unified.Resource{	for _, net := range resp.Networks {	var resources []unified.Resource	}		return nil, err	if err := json.Unmarshal(data, &resp); err != nil {	var resp neutronNetworksResponse	}		return nil, err	if err != nil {	data, err := c.doRequest(ctx, endpoint+"/v2.0/networks")	}		return nil, fmt.Errorf("network endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	endpoint := c.endpoints["network"]	c.mu.RLock()func (c *OpenStackCollector) discoverNetworks(ctx context.Context) ([]unified.Resource, error) {// discoverNetworks discovers Neutron networks.}	return resources, nil	}		resources = append(resources, resource)		}			},				"attachments":      vol.Attachments,				"created_at":       vol.CreatedAt,				"availability_zone": vol.AvailabilityZone,				"volume_type":      vol.VolumeType,				"size_gb":          vol.Size,			Properties: map[string]any{			Tags:     vol.Metadata,			Status:   vol.Status,			Region:   c.config.Region,			Provider: "openstack",			Type:     unified.ResourceTypeVolume,			Name:     vol.Name,			ID:       vol.ID,		resource := unified.Resource{	for _, vol := range resp.Volumes {	var resources []unified.Resource	}		return nil, err	if err := json.Unmarshal(data, &resp); err != nil {	var resp cinderVolumesResponse	}		return nil, err	if err != nil {	data, err := c.doRequest(ctx, endpoint+"/volumes/detail?all_tenants=true")	}		return nil, fmt.Errorf("volume endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	}		endpoint = c.endpoints["volume"]	if endpoint == "" {	endpoint := c.endpoints["volumev3"]	c.mu.RLock()func (c *OpenStackCollector) discoverVolumes(ctx context.Context) ([]unified.Resource, error) {// discoverVolumes discovers Cinder volumes.}	return resources, nil	}		resources = append(resources, resource)		}			},				"addresses":         srv.Addresses,				"flavor":            srv.Flavor,				"availability_zone": srv.AvailabilityZone,				"host":              srv.HostID,				"updated":           srv.Updated,				"created":           srv.Created,				"user_id":           srv.UserID,				"tenant_id":         srv.TenantID,			Properties: map[string]any{			Tags:     srv.Metadata,			Status:   srv.Status,			Region:   c.config.Region,			Provider: "openstack",			Type:     unified.ResourceTypeVM,			Name:     srv.Name,			ID:       srv.ID,		resource := unified.Resource{	for _, srv := range resp.Servers {	var resources []unified.Resource	}		return nil, err	if err := json.Unmarshal(data, &resp); err != nil {	var resp novaServersResponse	}		return nil, err	if err != nil {	data, err := c.doRequest(ctx, endpoint+"/servers/detail?all_tenants=true")	}		return nil, fmt.Errorf("compute endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	endpoint := c.endpoints["compute"]	c.mu.RLock()func (c *OpenStackCollector) discoverServers(ctx context.Context) ([]unified.Resource, error) {// discoverServers discovers Nova servers.}	return resources, nil	wg.Wait()	}()		}			mu.Unlock()			resources = append(resources, networks...)			mu.Lock()		if networks, err := c.discoverNetworks(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Discover networks	}()		}			mu.Unlock()			resources = append(resources, volumes...)			mu.Lock()		if volumes, err := c.discoverVolumes(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Discover volumes	}()		}			mu.Unlock()			resources = append(resources, servers...)			mu.Lock()		if servers, err := c.discoverServers(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Discover servers	var wg sync.WaitGroup	var mu sync.Mutex	var resources []unified.Resource	}		return nil, err	if err := c.ensureAuthenticated(ctx); err != nil {func (c *OpenStackCollector) DiscoverResources(ctx context.Context) ([]unified.Resource, error) {// DiscoverResources discovers OpenStack resources.}	return metrics, nil	}		}			}				})					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitBytes,					Value:     float64(bytes),					Type:      unified.MetricTypeGauge,					Name:      "openstack.swift.bytes_used",				metrics = append(metrics, unified.Metric{			if bytes, err := strconv.ParseInt(bytesUsed, 10, 64); err == nil {		if bytesUsed := resp.Header.Get("X-Account-Bytes-Used"); bytesUsed != "" {		}			}				})					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.swift.objects.total",				metrics = append(metrics, unified.Metric{			if count, err := strconv.Atoi(objectCount); err == nil {		if objectCount := resp.Header.Get("X-Account-Object-Count"); objectCount != "" {		}			}				})					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.swift.containers.total",				metrics = append(metrics, unified.Metric{			if count, err := strconv.Atoi(containerCount); err == nil {		if containerCount := resp.Header.Get("X-Account-Container-Count"); containerCount != "" {		// Parse headers for account statistics	if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusNoContent {	defer resp.Body.Close()	}		return nil, err	if err != nil {	resp, err := c.client.Do(req)	c.mu.RUnlock()	req.Header.Set("X-Auth-Token", c.token)	c.mu.RLock()	}		return nil, err	if err != nil {	req, err := http.NewRequestWithContext(ctx, "HEAD", endpoint, nil)	// Get account stats	now := time.Now()	var metrics []unified.Metric	}		return nil, fmt.Errorf("object-store endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	endpoint := c.endpoints["object-store"]	c.mu.RLock()func (c *OpenStackCollector) collectSwiftMetrics(ctx context.Context) ([]unified.Metric, error) {// collectSwiftMetrics collects metrics from Swift (Object Storage).}	return metrics, nil	}		}			})				Labels:    map[string]string{},				Timestamp: now,				Unit:      unified.MetricUnitCount,				Value:     float64(len(sgResp.SecurityGroups)),				Type:      unified.MetricTypeGauge,				Name:      "openstack.neutron.security_groups.total",			metrics = append(metrics, unified.Metric{		if json.Unmarshal(secGroups, &sgResp) == nil {		var sgResp neutronSecurityGroupsResponse	if err == nil {	secGroups, err := c.doRequest(ctx, endpoint+"/v2.0/security-groups")	// Get security groups	}		}			}				})					Labels:    map[string]string{"status": status},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.neutron.ports",				metrics = append(metrics, unified.Metric{			for status, count := range statusCounts {			}				statusCounts[p.Status]++			for _, p := range portResp.Ports {			statusCounts := make(map[string]int)		if json.Unmarshal(ports, &portResp) == nil {		var portResp neutronPortsResponse	if err == nil {	ports, err := c.doRequest(ctx, endpoint+"/v2.0/ports")	// Get ports	}		}			)				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(used),					Type:      unified.MetricTypeGauge,					Name:      "openstack.neutron.floating_ips.used",				unified.Metric{				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(len(fipResp.FloatingIPs)),					Type:      unified.MetricTypeGauge,					Name:      "openstack.neutron.floating_ips.total",				unified.Metric{			metrics = append(metrics,			}				}					used++				if fip.PortID != "" {			for _, fip := range fipResp.FloatingIPs {			used := 0		if json.Unmarshal(floatingIPs, &fipResp) == nil {		var fipResp neutronFloatingIPsResponse	if err == nil {	floatingIPs, err := c.doRequest(ctx, endpoint+"/v2.0/floatingips")	// Get floating IPs	}		}			})				Labels:    map[string]string{},				Timestamp: now,				Unit:      unified.MetricUnitCount,				Value:     float64(len(routerResp.Routers)),				Type:      unified.MetricTypeGauge,				Name:      "openstack.neutron.routers.total",			metrics = append(metrics, unified.Metric{			}				})					Labels:    map[string]string{"status": status},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.neutron.routers",				metrics = append(metrics, unified.Metric{			for status, count := range statusCounts {			}				statusCounts[r.Status]++			for _, r := range routerResp.Routers {			statusCounts := make(map[string]int)		if json.Unmarshal(routers, &routerResp) == nil {		var routerResp neutronRoutersResponse	if err == nil {	routers, err := c.doRequest(ctx, endpoint+"/v2.0/routers")	// Get routers	}		}			})				Labels:    map[string]string{},				Timestamp: now,				Unit:      unified.MetricUnitCount,				Value:     float64(len(netResp.Networks)),				Type:      unified.MetricTypeGauge,				Name:      "openstack.neutron.networks.total",			metrics = append(metrics, unified.Metric{		if json.Unmarshal(networks, &netResp) == nil {		var netResp neutronNetworksResponse	if err == nil {	networks, err := c.doRequest(ctx, endpoint+"/v2.0/networks")	// Get networks	now := time.Now()	var metrics []unified.Metric	}		return nil, fmt.Errorf("network endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	endpoint := c.endpoints["network"]	c.mu.RLock()func (c *OpenStackCollector) collectNeutronMetrics(ctx context.Context) ([]unified.Metric, error) {// collectNeutronMetrics collects metrics from Neutron (Networking).}	return metrics, nil	}		}			)				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitGigabytes,					Value:     float64(totalSize),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.snapshots.size_gb",				unified.Metric{				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(len(snapResp.Snapshots)),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.snapshots.total",				unified.Metric{			metrics = append(metrics,			}				totalSize += snap.Size			for _, snap := range snapResp.Snapshots {			var totalSize int		if json.Unmarshal(snapshots, &snapResp) == nil {		var snapResp cinderSnapshotsResponse	if err == nil {	snapshots, err := c.doRequest(ctx, endpoint+"/snapshots/detail?all_tenants=true")	// Get snapshots	}		}			)				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitGigabytes,					Value:     float64(usedSize),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.capacity.used_gb",				unified.Metric{				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitGigabytes,					Value:     float64(totalSize),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.capacity.total_gb",				unified.Metric{				},					Labels:    map[string]string{},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(len(volResp.Volumes)),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.volumes.total",				unified.Metric{			metrics = append(metrics,			}				})					Labels:    map[string]string{"status": state},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.cinder.volumes",				metrics = append(metrics, unified.Metric{			for state, count := range stateCounts {			}				}					usedSize += vol.Size				if vol.Status == "in-use" {				totalSize += vol.Size				stateCounts[vol.Status]++			for _, vol := range volResp.Volumes {			stateCounts := make(map[string]int)			var totalSize, usedSize int		if json.Unmarshal(volumes, &volResp) == nil {		var volResp cinderVolumesResponse	if err == nil {	volumes, err := c.doRequest(ctx, endpoint+"/volumes/detail?all_tenants=true")	// Get volumes	now := time.Now()	var metrics []unified.Metric	}		return nil, fmt.Errorf("volume endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	}		endpoint = c.endpoints["volume"]	if endpoint == "" {	endpoint := c.endpoints["volumev3"]	c.mu.RLock()func (c *OpenStackCollector) collectCinderMetrics(ctx context.Context) ([]unified.Metric, error) {// collectCinderMetrics collects metrics from Cinder (Block Storage).}	return metrics, nil	}		}			})				Labels:    map[string]string{},				Timestamp: now,				Unit:      unified.MetricUnitCount,				Value:     float64(len(srvResp.Servers)),				Type:      unified.MetricTypeGauge,				Name:      "openstack.nova.servers.total",			metrics = append(metrics, unified.Metric{			}				})					Labels:    map[string]string{"status": state},					Timestamp: now,					Unit:      unified.MetricUnitCount,					Value:     float64(count),					Type:      unified.MetricTypeGauge,					Name:      "openstack.nova.servers",				metrics = append(metrics, unified.Metric{			for state, count := range stateCounts {			}				stateCounts[srv.Status]++			for _, srv := range srvResp.Servers {			stateCounts := make(map[string]int)			// Count servers by state		if json.Unmarshal(servers, &srvResp) == nil {		var srvResp novaServersResponse	if err == nil {	servers, err := c.doRequest(ctx, endpoint+"/servers/detail?all_tenants=true")	// Get server statistics	}		}			}				)					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitCount,						Value:     float64(hv.RunningVMs),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.running_vms",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitGigabytes,						Value:     float64(hv.LocalGBUsed),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.local_gb_used",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitGigabytes,						Value:     float64(hv.LocalGB),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.local_gb",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitMegabytes,						Value:     float64(hv.MemoryMBUsed),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.memory_used_mb",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitMegabytes,						Value:     float64(hv.MemoryMB),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.memory_mb",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitCount,						Value:     float64(hv.VCPUsUsed),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.vcpus_used",					unified.Metric{					},						Labels:    labels,						Timestamp: now,						Unit:      unified.MetricUnitCount,						Value:     float64(hv.VCPUs),						Type:      unified.MetricTypeGauge,						Name:      "openstack.hypervisor.vcpus",					unified.Metric{				metrics = append(metrics,				}					"status":          hv.Status,					"state":           hv.State,					"hypervisor_type": hv.Type,					"hypervisor":      hv.Name,				labels := map[string]string{			for _, hv := range hvResp.Hypervisors {		if json.Unmarshal(hypervisors, &hvResp) == nil {		var hvResp novaHypervisorsResponse	if err == nil {	hypervisors, err := c.doRequest(ctx, endpoint+"/os-hypervisors/detail")	// Get hypervisors statistics	now := time.Now()	var metrics []unified.Metric	}		return nil, fmt.Errorf("compute endpoint not found")	if endpoint == "" {	c.mu.RUnlock()	endpoint := c.endpoints["compute"]	c.mu.RLock()func (c *OpenStackCollector) collectNovaMetrics(ctx context.Context) ([]unified.Metric, error) {// collectNovaMetrics collects metrics from Nova (Compute).}	return metrics, nil	wg.Wait()	}()		}			mu.Unlock()			metrics = append(metrics, swiftMetrics...)			mu.Lock()		if swiftMetrics, err := c.collectSwiftMetrics(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Collect from Swift	}()		}			mu.Unlock()			metrics = append(metrics, neutronMetrics...)			mu.Lock()		if neutronMetrics, err := c.collectNeutronMetrics(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Collect from Neutron	}()		}			mu.Unlock()			metrics = append(metrics, cinderMetrics...)			mu.Lock()		if cinderMetrics, err := c.collectCinderMetrics(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Collect from Cinder	}()		}			mu.Unlock()			metrics = append(metrics, novaMetrics...)			mu.Lock()		if novaMetrics, err := c.collectNovaMetrics(ctx); err == nil {		defer wg.Done()	go func() {	wg.Add(1)	// Collect from Nova	var wg sync.WaitGroup	var mu sync.Mutex	var metrics []unified.Metric	}		return nil, err	if err := c.ensureAuthenticated(ctx); err != nil {func (c *OpenStackCollector) CollectMetrics(ctx context.Context) ([]unified.Metric, error) {// CollectMetrics collects metrics from all OpenStack services.}	return c.Authenticate(ctx)	}		return nil	if valid {	c.mu.RUnlock()	valid := c.token != "" && time.Now().Add(5*time.Minute).Before(c.tokenExpiry)	c.mu.RLock()func (c *OpenStackCollector) ensureAuthenticated(ctx context.Context) error {// ensureAuthenticated ensures we have a valid token.}	return nil	c.mu.Unlock()	}		}			}				c.endpoints[service.Type] = endpoint.URL			if endpoint.Interface == "public" {		for _, endpoint := range service.Endpoints {	for _, service := range authResp.Token.Catalog {	c.mu.Lock()	// Build endpoints map from catalog	}		c.mu.Unlock()		c.tokenExpiry = expiry		c.mu.Lock()	if err == nil {	expiry, err := time.Parse(time.RFC3339, authResp.Token.ExpiresAt)	// Parse token expiry	}		return fmt.Errorf("failed to parse auth response: %w", err)	if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {	var authResp keystoneAuthResponse	// Parse response for catalog and expiry	c.mu.Unlock()	c.token = resp.Header.Get("X-Subject-Token")	c.mu.Lock()	// Get token from header	}		return fmt.Errorf("authentication failed: %s - %s", resp.Status, string(respBody))		respBody, _ := io.ReadAll(resp.Body)	if resp.StatusCode != http.StatusCreated {	defer resp.Body.Close()	}		return fmt.Errorf("failed to authenticate: %w", err)	if err != nil {	resp, err := c.client.Do(req)	req.Body = io.NopCloser(newBytesReader(body))	req.Header.Set("Content-Type", "application/json")	}		return fmt.Errorf("failed to create auth request: %w", err)	if err != nil {	req, err := http.NewRequestWithContext(ctx, "POST", authURL, nil)	}		return fmt.Errorf("failed to marshal auth request: %w", err)	if err != nil {	body, err := json.Marshal(authReq)	}		},			},				},					},						Name: c.config.DomainName,					Domain: keystoneDomain{					Name: c.config.ProjectName,				Project: keystoneProject{			Scope: keystoneScope{			},				},					},						},							Name: c.config.DomainName,						Domain: keystoneDomain{						Password: c.config.Password,						Name:     c.config.Username,					User: keystoneUser{				Password: keystonePassword{				Methods: []string{"password"},			Identity: keystoneIdentity{		Auth: keystoneAuth{	authReq := keystoneAuthRequest{	// Build authentication request	authURL := c.config.AuthURL + "/auth/tokens"func (c *OpenStackCollector) Authenticate(ctx context.Context) error {// Authenticate authenticates with Keystone and retrieves service catalog.}	}		endpoints: make(map[string]string),		client:    &http.Client{Timeout: 30 * time.Second},		config:    config,	return &OpenStackCollector{func NewOpenStackCollector(config unified.OpenStackConfig) *OpenStackCollector {// NewOpenStackCollector creates a new OpenStack collector.}	mu          sync.RWMutex	endpoints   map[string]string // service type -> endpoint URL	tokenExpiry time.Time	token       string	client      *http.Client	config      unified.OpenStackConfigtype OpenStackCollector struct {// OpenStackCollector collects metrics and resources from OpenStack.)	"github.com/platformbuilds/telegen/internal/cloud/unified"	"time"	"sync"	"net/http"	"io"